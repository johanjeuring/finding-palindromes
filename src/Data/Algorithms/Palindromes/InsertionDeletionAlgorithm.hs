{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE MonoLocalBinds #-}

module Data.Algorithms.Palindromes.InsertionDeletionAlgorithm (Cell (..), insertionDeletionAlgorithm, sparsify) where

import Data.Algorithms.Palindromes.PalEq (PalEq, (=:=))
import Data.Algorithms.Palindromes.Transducers
    ( TransduceExtractor (..)
    , transducel1
    , transducel2
    )

import qualified Data.Vector as V

{- | Represents the range of the substring of the input string containing a palindrome.
Format: ([start index (inclusive)], [end index (exclusive)]).
-}
type PalRange = (Int, Int)

{- | Represents a cell in the matrix. Each cell corresponds to some substring of the input
string. The row is the index of the first character (inclusive) and the column is the
index of the last character (inclusive) of the substring.
-}
data Cell = Cell
    { cellColumn :: Int
    , cellBudget :: Budget
    }
    deriving (Show, Eq)

-- | Represents a row in the matrix.
type Row = [Cell]

{- | The budget of a cell is the number of errors that can be added to the substring the
cell corresponds to without exceeding the maximum number of errors.
-}
type Budget = Int

{- | Find all maximal gapped approximate palindromes with a certain gap and a certain
maximum number of errors.
-}
insertionDeletionAlgorithm
    :: (PalEq a)
    => Int
    -- ^ The size of the gap
    -> Int
    -- ^ The maximum number of errors
    -> V.Vector a
    -- ^ The input vector
    -> [PalRange]
    -- ^ The list of found maximal gapped approximate palindromes
insertionDeletionAlgorithm gapSize maxErrors input = concatMap (\(_, y, _) -> y) states
  where
    -- Use iterateTimes to get the states for efficiency.
    states = iterateTimes nrOfIterations (fillRow input gapSize maxErrors) startState
    {- Required number of iterations is (+ 2) to also be able to spot maximal palindromes
    in the two upper rows. -}
    nrOfIterations = maxRow + 2
    startState =
        (
            [ Cell
                { cellColumn = startColumn
                , cellBudget = startBudget
                }
            ] -- This defines the entire bottom row of the matrix.
        , [] -- no maximal palindromes found yet.
        , maxRow - 1 -- row number of the row above the bottom row of the matrix.
        )
    -- The index of the last row.
    maxRow = V.length input - 1
    -- The column of the leftmost cell we use on the bottom row.
    startColumn = maxRow + gapSize
    -- The budget for the leftmost cell we use on the bottom row.
    startBudget
        | startColumn >= V.length input = -1
        | otherwise = maxErrors - errorCostAtPosition input (maxRow, startColumn)

-- | Fills the next row and finds maximal palindromes in the previous row
fillRow
    :: (PalEq a)
    => V.Vector a
    -- ^ Input vector
    -> Int
    -- ^ Maximum size of the gap
    -> Int
    -- ^ Maximum number of errors
    -> (Row, [PalRange], Int)
    -- ^ Old state of the transducer
    -> (Row, [PalRange], Int)
    -- ^ New state of the transducer
fillRow input gapSize maxErrors (row, _, rowIndex) = (newRow, foundMaxPals, rowIndex - 1)
  where
    {- The first cell of the row below the current row. A new cell needs to be added at
    the start of the previous row because we don't add one in the evaluatePosition part
    and every row is extended one to the left when you go up one row. -}
    firstCellPrevRow = Cell{cellColumn = initialColumn, cellBudget = initialBudget}

    {- The initial column is directly below the diagonal on the previous row, so the
    current rowIndex shifted by the gapSize. -}
    initialColumn = rowIndex + gapSize

    -- The budget of the first cell of the previous row
    initialBudget :: Budget
    initialBudget
        {- For the top row, the first cell has maxErrors, but only if the column is in
        the bounds. -}
        | rowIndex == -1 && initialColumn >= 0 = maxErrors
        {- For rows or columns out of bounds, the first cell of the previous row has no
        budget left, because it represents an invalid substring. -}
        | rowIndex < 0 || initialColumn >= V.length input = -1
        {- In general, the first cell of the previous row has a budget of maxErrors,
        because it represent an empty substring, which has no errors. -}
        | otherwise =
            maxErrors

    -- Sparsify the previous row.
    sparsecells =
        sparsify (firstCellPrevRow : row)

    {- Do a transducel2 using the previous, sparsified row. EvaluatePosition generates
    tuples with the cell at a position as the second element and the cell to the
    bottomleft of the evaluated position as a found gapped approximate maximal palindrome
    if it is one. The TransduceExtractors thus only need to extract the second and third
    elements of the tuples generated by evaluatePostion for each position. -}
    (newRow, foundMaxPals) =
        transducel2
            (evaluatePosition input rowIndex)
            (TransExtract (\(_, y, _) -> y) (const []))
            (TransExtract (\(_, _, z) -> z) (const []))
            {- The row starts with 2 (virtual so they do not appear in the rows) cells
            initialized to maxbudget. One to the left of the current row and one to the
            left of the previous row. -}
            ((maxErrors, maxErrors), [], [])
            sparsecells

{- | Define a new cell (the cell above the input cell) with the correct budget and add
bottom left cell to maxPals if it is maximal.

Consider the following matrix:
------------------------------
| topLeft        topRight    |
| bottomLeft     bottomRight |
------------------------------

We want to define the budget in topRight and check whether bottomLeft is maximal.
-}
evaluatePosition
    :: (PalEq a)
    => V.Vector a
    -- ^ Input vector
    -> Int
    -- ^ row index
    -> ((Budget, Budget), Row, [PalRange])
    -- ^ Old state for the transducer
    -> Cell
    -- ^ Input cell
    -> ((Budget, Budget), Row, [PalRange])
    -- ^ New state for the transducer
evaluatePosition input rowIndex ((topLeft, bottomLeft), _, _) (Cell{cellColumn = column, cellBudget = bottomRight}) =
    ((topRight, bottomRight), [Cell column topRight], maxpals)
  where
    topRight
        | rowIndex >= 0 && column < V.length input =
            maximum
                [ topLeft - 1
                , bottomRight - 1
                , bottomLeft - errorCostAtPosition input (rowIndex, column)
                ]
        | otherwise = -1
    maxpals =
        {- add (+ 1) to get inclusive start index and exclusive end index for the found
        maximal palindromes -}
        [ (rowIndex + 1, column)
        | bottomLeft >= 0 && topLeft < 0 && topRight < 0 && bottomRight < 0
        ]

{- | Replace long sequences of cells with (-1) budgets with two cells with (-1) budgets,
one on either end of the sequence.
-}
sparsify :: Row -> Row
sparsify [] = []
sparsify row@(Cell{cellColumn = firstColumnIndex, cellBudget = _} : _) =
    transducel1
        insertNegatives
        (TransExtract snd endf)
        (firstColumnIndex, [])
        (filter ((>= 0) . cellBudget) row)
  where
    insertNegatives :: (Int, Row) -> Cell -> (Int, Row)
    insertNegatives (lastind, _) newCell@Cell{cellColumn = newIndex}
        -- Place two cells on either side of the sequence of negative budgets.
        | newIndex - lastind > 2 =
            ( newIndex
            ,
                [ Cell{cellColumn = lastind + 1, cellBudget = -1}
                , Cell{cellColumn = newIndex - 1, cellBudget = -1}
                , newCell
                ]
            )
        -- Add one cell with (-1) budget back after it has apparently been filtered out before.
        | newIndex - lastind == 2 =
            (newIndex, [Cell{cellColumn = lastind + 1, cellBudget = -1}, newCell])
        -- Do nothing.
        | otherwise = (newIndex, [newCell])

    -- Always add one -1 to the end of the sparsified row
    endf (lastPositiveColumnIndex, _) =
        [Cell{cellColumn = lastPositiveColumnIndex + 1, cellBudget = -1}]

-- | Returns first n elements of iterate f on start. This function is quite efficient.
iterateTimes :: Int -> (a -> a) -> a -> [a]
iterateTimes n f start = take n $ iterate f start

{- If elements are palindrome equal at position then no error cost, otherwise error cost
of 1 for a substitution error. -}
errorCostAtPosition :: (PalEq a) => V.Vector a -> (Int, Int) -> Int
errorCostAtPosition input (row, column)
    | (input V.! row) =:= (input V.! column) = 0
    | otherwise = 1
